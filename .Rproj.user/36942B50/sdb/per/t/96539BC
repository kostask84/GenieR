{
    "collab_server" : "",
    "contents" : "\n#####################################################################\n##############Geniefit###############################################\n#####################################################################\n\n#########introduce function: branching.sampling.times and heterochronous.gp.stat from###\n##########https://github.com/sdwfrost/pangea/blob/master/skyride/skyride.Rmd###########\n\n#' Simulate coalescent times for heterochronous data.\n#'\n#' \\code{coalgen_hetero} simulates coalescent times for heterochronous data.\n#'\n#' @param sample A two columns matrix of number of individuals and the initial time.\n#' @param trajectory A population growth function.\n#' @param val_upper Upper end of time points to be simulated.\n#'\n#'\n#' @return Coalescent intervals and lineages.\n#'\n#' @references \\url{https://github.com/JuliaPalacios/coalsieve}.\n#'\n#'@export\n#'\n#' @examples\n#' sample1<-cbind(c(9,1,2,1),c(0,.008,.03,.1))\n#'\n#' trajectory<-function(x)  exp(10*x)\n#' example_hetero<-coalgen_hetero(sample1, trajectory)\n#'\n#'\n#'\ncoalgen_hetero <-function(sample, trajectory,val_upper=10){\n  #'sample = is a matrix with 2 columns. The first column contains the number of samples collected at the time defined in the second column\n  #'trajectory = one over the effective population size function\n  # this works for heterochronous sampling\n  # assumes sample[1,1]>1\n  s=sample[1,2]\n  b<-sample[1,1]\n  n<-sum(sample[,1])-1\n  m<-n\n  nsample<-nrow(sample)\n  sample<-rbind(sample,c(0,10))\n  out<-rep(0,n)\n  branches<-rep(0,n)\n  i<-1\n  while (i<(nsample+1)){\n    if (b==1) {break}\n    if (b<2){\n      b<-b+sample[i+1,1]\n      s<-sample[i+1,2]\n      i<-i+1\n    }\n    x<-rexp(1)\n    f <- function(bran,u,x,s) .5*bran*(bran-1)*integrate(trajectory, s, s+u)$value - x\n    y<-uniroot(f,bran=b,x=x,s=s,lower=0,upper=val_upper)$root\n    while ( (s+y)>sample[i+1,2]) {\n      #     f <- function(bran,u,x,s) .5*bran*(bran-1)*integrate(trajectory, s, s+u)$value - x\n      #     y<-uniroot(f,bran=b,x=x,s=s,lower=0,upper=val_upper)$root\n      x<-x-.5*b*(b-1)*integrate(trajectory,s,sample[i+1,2])$value\n      b<-b+sample[i+1,1]\n      s<-sample[i+1,2]\n      i<-i+1\n      f <- function(bran,u,x,s) .5*bran*(bran-1)*integrate(trajectory, s, s+u)$value - x\n      y<-uniroot(f,bran=b,x=x,s=s,lower=0,upper=val_upper)$root\n      if (i==nsample) {sample[nsample+1,2]<-10*(s+y)}\n    }\n\n    s<-s+y\n    out[m-n+1]<-s\n    branches[m-n+1]<-b\n    n<-n-1\n    b<-b-1\n    if (i==nsample) {sample[nsample+1,2]<-10*(s+y)}\n\n  }\n\n  return(list(branches=c(out[1],diff(out)),lineages=branches))\n}\n\n\n#' Simulate coalescent times for isochronous data.\n#'\n#' \\code{coalgen_iso} simulates coalescent times for isochronous data.\n#'\n#' @param sample A two dimensional vector of number of individuals and the initial time.\n#' @param trajectory A population growth function.\n#' @param val_upper Upper end of time points to be simulated.\n#'\n#'\n#' @return Coalescent intervals and lineages.\n#'\n#' @references \\url{https://github.com/JuliaPalacios/coalsieve}.\n#'\n#' @export\n#'\n#' @examples\n#' sample<-c(100,0)\n#'\n#' trajectory<-function(x)  exp(10*x)\n#' example_iso<-coalgen_iso(sample, trajectory)\n#'\ncoalgen_iso<-function(sample, trajectory,val_upper=10){\n  #'sample = is a matrix with 2 columns. The first column contains the number of samples collected at the time defined in the second column\n  #'trajectory = one over the effective population size function\n  # this works for isochronous sampling\n  s=sample[2]\n  n<-sample[1]\n  out<-rep(0,n-1)\n  #   val_upper<-10*(1/choose(n+1,3))\n  for (j in n:2){\n    t=rexp(1,choose(j,2))\n    #' trajectory is the inverse of the effective population size function\n    f <- function(x,t,s) integrate(trajectory, s, s+x)$value - t\n    #--- I will probably need to catch an error here, for val_upper, it breaks if\n    # val_upper is not large enough\n    #    val_upper<-10\n    y<-uniroot(f,t=t,s=s,lower=0,upper=val_upper)$root\n    s<-s+y\n    out[n-j+1]<-s\n  }\n  return(list(branches=c(out[1],diff(out)),lineages=seq(n,2,-1)))\n\n}\n\n\n\n\n\n#' Extract sampling and coalescent times from a phylogenetic tree.\n#'\n#' \\code{branching.sampling.times} extracts sampling and coalescent times from a phylogenetic tree.\n#'\n#' @param phy A phylogenetic tree.\n#'\n#'\n#' @return Sampling times and coalescent times\n#'\n#' @references Palacios JA and Minin VN. Integrated nested Laplace approximation for Bayesian nonparametric phylodynamics, in Proceedings of the Twenty-Eighth Conference on Uncertainty in Artificial Intelligence, 2012.\n#'\n#' @examples\n#' library(ape)\n#' t1=rcoal(20)\n#' branching.sampling.times(t1)\n#'\n#'\n#' @export\nbranching.sampling.times <- function(phy){\n  phy = new2old.phylo(phy)\n  if (class(phy) != \"phylo\")\n    stop(\"object \\\"phy\\\" is not of class \\\"phylo\\\"\")\n  tmp <- as.numeric(phy$edge)\n  nb.tip <- max(tmp)\n  nb.node <- -min(tmp)\n  xx <- as.numeric(rep(NA, nb.tip + nb.node))\n  names(xx) <- as.character(c(-(1:nb.node), 1:nb.tip))\n  xx[\"-1\"] <- 0\n  for (i in 2:length(xx)) {\n    nod <- names(xx[i])\n    ind <- which(phy$edge[, 2] == nod)\n    base <- phy$edge[ind, 1]\n    xx[i] <- xx[base] + phy$edge.length[ind]\n  }\n  depth <- max(xx)\n  branching.sampling.times <- depth - xx\n  return(branching.sampling.times)\n}\n\n#' Sort out sampling times, coalescent times and sampling lineages from a phylogenetic tree\n#'\n#' \\code{heterochronous.gp.stat} sorts out sampling times, coalescent times and sampling lineages from a phylogenetic tree.\n#'\n#' @param phy A phylogenetic tree.\n#'\n#'\n#' @return Sorted sampling times, coalescent times and sampling lineages.\n#'\n#' @references Palacios JA and Minin VN. Integrated nested Laplace approximation for Bayesian nonparametric phylodynamics, in Proceedings of the Twenty-Eighth Conference on Uncertainty in Artificial Intelligence, 2012.\n#' @examples\n#' library(ape)\n#' t1=rcoal(20)\n#' heterochronous.gp.stat(t1)\n#'\n#' @export\n\n\n\n\nheterochronous.gp.stat <- function(phy){\n  b.s.times = branching.sampling.times(phy)\n  int.ind = which(as.numeric(names(b.s.times)) < 0)\n  tip.ind = which(as.numeric(names(b.s.times)) > 0)\n  num.tips = length(tip.ind)\n  num.coal.events = length(int.ind)\n  sampl.suf.stat = rep(NA, num.coal.events)\n  coal.interval = rep(NA, num.coal.events)\n  coal.lineages = rep(NA, num.coal.events)\n  sorted.coal.times = sort(b.s.times[int.ind])\n  names(sorted.coal.times) = NULL\n  #unique.sampling.times = sort(unique(b.s.times[tip.ind]))\n  sampling.times = sort((b.s.times[tip.ind]))\n  for (i in 2:length(sampling.times)){\n    if ((sampling.times[i]-sampling.times[i-1])<1e-6){\n      sampling.times[i]<-sampling.times[i-1]}\n  }\n  unique.sampling.times<-unique(sampling.times)\n  sampled.lineages = NULL\n  for (sample.time in unique.sampling.times){\n    sampled.lineages = c(sampled.lineages,\n                         sum(sampling.times == sample.time))\n  }\n  return(list(coal.times=sorted.coal.times, sample.times = unique.sampling.times, sampled.lineages=sampled.lineages))\n}\n\n\n\n\n#' A function to fit coalescent models to a given phylogenetic tree.\n#' @param phy A phylogenetic tree.\n#' @param Model A Model choice from const (constant population size), expo (exponetial growth),expan (expansion growth), log (logistic growth), step (piecewise constant), pexpan (piecewise expansion growth) and plog (piecewise logistic growth).\n#' @param start Initial values for the parameters to be optimized over.\n#' @param lower, upper Bounds on the variables.\n#' @return Parameters estimation of a given model, loglikelihood and AIC\n#' @examples\n#' library(ape)\n#' t1=rcoal(20)\n#' Geniefit(t1,Model=\"expo\",start=c(100,.1,.1),upper=Inf,lower=0)\n#' @export\n#######one function to produce the fit######\nGeniefit=function(phy,Model=\"user\",start,upper,lower){\n  #####wash the data from the tree file#########\n  phy.times=heterochronous.gp.stat (phy)\n  ##################times frame given the coalesent events#############\n  n=length(phy.times$coal.times)\n  coaltimes.pop=matrix(0,nrow=n,ncol=2)\n  coaltimes.pop[,1]=phy.times$coal.times\n  coaltimes.pop[,2]=-1\n  #################times frame given the sampled events################\n  xn=length(phy.times$sample.times)\n  samptimes.pop=matrix(0,nrow=xn,ncol=2)\n  samptimes.pop[,1]=phy.times$sample.times\n  samptimes.pop[,2]=phy.times$sampled.lineages\n  ######sorted time and index matrix#####\n  times.pop=rbind(samptimes.pop,coaltimes.pop)\n  sort.times.pop=times.pop\n  sort.times.pop[,1]=times.pop[,1][order(times.pop[,1])]\n  sort.times.pop[,2]=times.pop[,2][order(times.pop[,1])]\n  #####population at diffrent times###\n  pop.times=cumsum(sort.times.pop[,2])\n  #####type of time, 0 denoting sampling event and 1 denoting coalesent event####\n  type=c(rep(0,xn),rep(1,n))\n  sort.type=type[order(times.pop[,1])]\n  ntotal=length(sort.type)\n  #####if statement to get rid of first event when it is sampling event##########\n  if (pop.times[1]<2) {\n    pop.times=pop.times[-1]\n    sort.times.pop=sort.times.pop[-1,]\n    sort.times.pop[,1]=sort.times.pop[,1]-sort.times.pop[1,1]\n    ntotal=ntotal-1\n    sort.type=sort.type[-1]\n  }\n  ######population trajectory function#########\n  fnpar=function(parr){\n    ####function of t for population trajectory#####\n    fnt=function(t){\n      if (Model==\"const\") {trajectory=parr[1]}\n      if (Model==\"expo\")  {trajectory=parr[1]*exp(-parr[2]*t)}\n      if (Model==\"expan\") {trajectory=parr[1]*(parr[3]+(1-parr[3])*exp(-parr[2]*t))}\n      if (Model==\"log\")   {trajectory=parr[1]*((1+parr[3])/(1+parr[3]*exp(parr[2]*t)))}\n      if (Model==\"step\")  {trajectory=ifelse(t<parr[3],parr[1],parr[1]*parr[2])}\n      if (Model==\"pexpan\") {trajectory=ifelse(t<-log(parr[3])/parr[2],parr[1]*exp(-parr[2]*t),parr[1]*parr[3])}\n      return(1/trajectory)\n    }\n    ######define the integral explicit function given fnt###########\n    intfnt=function(lowerlim,upperlim){\n      if (Model==\"const\") {intg=1/parr[1]*(upperlim-lowerlim)}\n      if (Model==\"expo\")  {intg=1/parr[1]/parr[2]*(exp(parr[2]*upperlim)-exp(parr[2]*lowerlim))}\n      if (Model==\"expan\") {intg=1/parr[1]/parr[2]/parr[3]*(log(parr[3]*exp(parr[2]*upperlim)+1-parr[3])-log(parr[3]*exp(parr[2]*lowerlim)+1-parr[3]))}\n      if (Model==\"log\")   {intg=1/parr[1]/(1+parr[3])*(upperlim-lowerlim+parr[3]/parr[2]*(exp(parr[2]*upperlim)-exp(parr[2]*lowerlim)))}\n      if (Model==\"step\")  {\n        intg=ifelse(upperlim<parr[3],1/parr[1]*(upperlim-lowerlim),ifelse(lowerlim>parr[3],1/parr[1]/parr[2]*(upperlim-lowerlim),1/parr[1]*(parr[3]-lowerlim)+1/parr[1]/parr[2]*(upperlim-parr[3])) )\n      }\n      if (Model==\"pexpan\") {\n        intg=(upperlim< -log(parr[3])/parr[2])*1/parr[1]/parr[2]*(exp(parr[2]*upperlim)-exp(parr[2]*lowerlim))+(lowerlim>-log(parr[3])/parr[2])*1/parr[1]/parr[3]*(upperlim-lowerlim)+(lowerlim< -log(parr[3])/parr[2] && -log(parr[3])/parr[2]<upperlim)*(1/parr[1]/parr[3]*(upperlim+log(parr[3])/parr[2])+1/parr[1]/parr[2]*(exp(parr[2]*\n                                                                                                                                                                                                                                                                                                                                      -log(parr[3])/parr[2])-exp(parr[2]*lowerlim)))\n      }\n      return(intg)\n    }\n    logcoe=sort.type[-1]*(log(fnt(sort.times.pop[-1,1]))+log(pop.times[-ntotal]*(pop.times[-ntotal]-1)/2))\n    logint=-pop.times[-ntotal]*(pop.times[-ntotal]-1)/2*intfnt(sort.times.pop[-ntotal,1],sort.times.pop[-1,1])\n    return(-sum(logcoe)-sum(logint))\n\n  }\n  fn2 <- function(x){\n    fnpar(exp(x))\n  }\n  require(minqa)\n  fit2 <- bobyqa(log(start),fn2,lower=log(lower),upper=log(upper))\n  return(list(parr=exp(fit2$par),loglikelihood=-fit2$fval,AIC=2*length(start)+2*fit2$fval))\n}\n\n\n\n\n\n",
    "created" : 1473606605501.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1565232816",
    "id" : "96539BC",
    "lastKnownWriteTime" : 1475334681,
    "last_content_update" : 1475334681930,
    "path" : "~/genieR/R/rox.R",
    "project_path" : "R/rox.R",
    "properties" : {
    },
    "relative_order" : 5,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}